
AnLang:
    AnLang <  ModuleDeclaration? TopLevelStmt* endOfInput

    ModuleDeclaration <  'module ' QualName

    Name <- ;identifier
    QualName <- ;NoDiscardList(Name, NamespaceSep)

    TypeName <-
             /  FunctionType
             /  QualName ArrayLiteral+
             /  QualName

    FunctionType <  'fn' '(' TypeTuple? ')' (:ReturnTypeSigil TypeName)?
    TypeTuple <  (TypeName (Spacing ',' Spacing TypeName)*)?

    ArrayLiteral <
              /  '[' TypeName? ']'

    TopLevelStmt <
                 /  Definitions
                 /  Import

    Expr <- (
                # Top-level statements
                # Please do not put import in here
                (
                / Definitions
                )
            /
                # Non-statement expressions
                (
                / ExprIfElse
                / ExprClosure
                / SymbolName
                )
            ) ExprFollowUps?
    ExprFollowUps <
                  /  InfixExprSuffix+
                  /  (ExprPropertyAccess / FuncCallArgumentTuple)+

    SymbolName <  ;Name

    Import        <  'import ' QualName (':' ImportDetails)?
    ImportDetails <  ImportDetail (:Spacing ',' :Spacing ImportDetail)*
    ImportDetail  <  Name ('=' Name)?

    Definitions <  FunctionDefinition
              # /  TupleDefinition
              # /  StructDefinition
              # /  TypeDefinition

    FunctionDefinition              <  'fn ' FunctionDefinitionHeader FunctionDefinitionBody
    FunctionDefinitionHeader        <  Name FunctionDefinitionArgumentTuple (ReturnTypeSigil TypeName)?
    FunctionDefinitionArgumentTuple <  '(' (FunctionDefinitionArgument (:Spacing ',' :Spacing FunctionDefinitionArgument)*)? ')'
    FunctionDefinitionArgument      <  Name (':' TypeName)? ('=' Expr)?

    FunctionDefinitionBody <  ScopeStart FunctionBodyStmt* ScopeEnd
    FunctionBodyStmt       <
                           /  AssignStmt
                           /  ReturnStmt
                           /  AssertStmt
                           /  PrintStmt
                           /  Expr

    # Note that we can assign imports to symbols
    AssignStmt <  Name (':' TypeName)? '=' (Import / Expr)
    ReturnStmt <  'return ' Expr
    AssertStmt <  'assert ' Expr
    PrintStmt  <  'print '  Expr

    ExprClosure <  (FunctionDefinitionArgumentTuple / Name) :ClosureSigil (ScopeStart Expr* ScopeEnd / Expr)

    ExprIfElse <  'if ' ExprCond IfScopeStart ExprIfBody ScopeEnd
                  ('else ' ScopeStart ExprIfBody ScopeEnd)?
    ExprCond   <  Expr
    ExprIfBody <  (:Spacing FunctionBodyStmt)*

    InfixExprSuffix <  '`' QualName '`' Expr

    ExprFuncCall <  QualName FuncCallArgumentTuple
    FuncCallArgumentTuple < '(' (FuncCallArgument (',' :Spacing FuncCallArgument)*)? ')'
    FuncCallArgument <
                     /  Name '=' Expr
                     /  Expr

    ExprPropertyAccess <  '.' Name

    ExprString <-
               /        quote Escapeables(      quote)       quote
               /  doublequote Escapeables(doublequote) doublequote

    # Tokens

    ScopeStart <: '{'
    ScopeEnd   <: '}'
    IfScopeStart <: ScopeStart

    NamespaceSep <~ '.'

    ReturnTypeSigil <~ '->'
    ClosureSigil    <~ '->'

    LineComment      <- "//" AllUntil(NewLine)
    MultiLineComment <- "/*" ~(MultiLineComment / Text)* "*/"

    DiscardableComments <- LineComment
                        /  MultiLineComment

    Text <~ (!("/*" / "*/") .)*

    AnyCharButLF <~ !NewLine .

    NewLine <- '\n' / '\r\n'
    Spacing <: (blank+ / DiscardableComments)*
    ExplicitSpacing <: (blank+ / DiscardableComments)+

    EscapeSequence <~ backslash ( quote
                                / doublequote
                                / backslash
                                / [abfnrtv]
                                )

    # Parameterized rules

    Escapeables(Char) <~ EscapeSequence
                     /  !Char .

    # Stolen from the docs ^^
    MaybeList(Elem, Sep)       <~ (Elem (Spacing :Sep Spacing Elem)*)?
    List(Elem, Sep)            <~ Elem (Spacing :Sep Spacing Elem)*
    NoDiscardList(Elem, Sep)   <~ Elem (Spacing Sep Spacing Elem)*
    Until(Expr, Pred)          <- (!Pred Expr)*
    AllUntil(Pred)             <~ Until(., Pred)
