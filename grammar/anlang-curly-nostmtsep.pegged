
AnLang:
    AnLang <  ModuleDeclaration? TopLevelStmt* endOfInput

    ModuleDeclaration <  'module ' QualName

    Name <- ;identifier
    QualName <- ;NoDiscardList(Name, NamespaceSep)

    TypeName <-
             /  FunctionType
             /  QualName ArrayLiteral+
             /  QualName

    FunctionType <  'fn' '(' TypeTuple? ')' (:ReturnTypeSigil TypeName)?
    TypeTuple <  (TypeName (Spacing ',' Spacing TypeName)*)?

    ArrayLiteral <
              /  '[' TypeName? ']'

    TopLevelStmt <
                 /  ~ExprTLStmt
                 /  Import

    ExprTLStmt <-
               /  ~Definitions
    ExprWOTLStmt <-
                 /  ExprIfElse
                 /  ExprClosure
                 /  QualName

    Expr <- (ExprTLStmt / ExprWOTLStmt) ExprFollowUps?
    ExprFollowUps <
                  /  InfixExprSuffix+
                  /  FuncCallArgumentTuple+
    InfixExprSuffix <  '`' QualName '`' Expr

    Import        <  'import ' QualName (':' ImportDetails)?
    ImportDetails <  ImportDetail (:Spacing ',' :Spacing ImportDetail)*
    ImportDetail  <  Name ('=' Name)?

    Definitions <  FunctionDefinition
              # /  TupleDefinition
              # /  StructDefinition
              # /  TypeDefinition

    FunctionDefinition              <  'fn ' FunctionDefinitionHeader FunctionDefinitionBody
    FunctionDefinitionHeader        <  Name FunctionDefinitionArgumentTuple (ReturnTypeSigil TypeName)?
    FunctionDefinitionArgumentTuple <  '(' (FunctionDefinitionArgument (:Spacing ',' :Spacing FunctionDefinitionArgument)*)? ')'
    FunctionDefinitionArgument      <  Name (':' TypeName)? ('=' Expr)?

    FunctionDefinitionBody <  ScopeStart FunctionBodyStmt* ScopeEnd
    FunctionBodyStmt       <  ~TopLevelStmt
                           /  ~ExprWOTLStmt # ExprTLStmt already contained in TopLevelStmt
                           /  AssignStmt
                           /  ReturnStmt
                           /  AssertStmt
                           /  PrintStmt

    AssignStmt <  Name (':' TypeName)? '=' Expr
    ReturnStmt <  KeywordStmt('return')
    AssertStmt <  KeywordStmt('assert')
    PrintStmt  <  KeywordStmt('print')

    ExprClosure <  (FunctionDefinitionArgumentTuple / Name) :ClosureSigil Expr

    ExprIfElse <  'if ' ExprWOTLStmt  IfScopeStart (Expr / AssignStmt)* ScopeEnd
                  ('else ' ScopeStart (Expr / AssignStmt)* ScopeEnd)?

    ExprFuncCall <  QualName FuncCallArgumentTuple
    FuncCallArgumentTuple < '(' (FuncCallArgument (',' :Spacing FuncCallArgument)*)? ')'
    FuncCallArgument <
                     /  Name '=' Expr
                     /  Expr

    # Tokens

    ScopeStart <~ '{'
    ScopeEnd   <~ '}'
    IfScopeStart <~ ScopeStart

    NamespaceSep <~ '.'

    ReturnTypeSigil <~ '->'
    ClosureSigil    <~ '->'

    LineComment      <- "//" AllUntil(NewLine)
    MultiLineComment <- "/*" ~(MultiLineComment / Text)* "*/"

    DiscardableComments <- LineComment
                        /  MultiLineComment

    Text <~ (!("/*" / "*/") .)*

    AnyCharButLF <~ !NewLine .

    NewLine <- '\n' / '\r\n'
    Spacing <: (blank+ / DiscardableComments)*
    ExplicitSpacing <: (blank+ / DiscardableComments)+

    EscapeSequence <~ backslash ( quote
                                / doublequote
                                / backslash
                                / [abfnrtv]
                                )

    # Parameterized rules

    KeywordStmt(Keyword) <- Keyword :ExplicitSpacing Expr
    Escapeable(Char) <- EscapeSequence
                     /  !Char .

    # Stolen from the docs ^^
    MaybeList(Elem, Sep)       <~ (Elem (Spacing :Sep Spacing Elem)*)?
    List(Elem, Sep)            <~ Elem (Spacing :Sep Spacing Elem)*
    NoDiscardList(Elem, Sep)   <~ Elem (Spacing Sep Spacing Elem)*
    Until(Expr, Pred)          <- (!Pred Expr)*
    AllUntil(Pred)             <~ Until(., Pred)
